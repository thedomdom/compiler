/* Project:  COCKTAIL training
 * Descr:    A simple pocket computer (scanner, parser, AST construction)
 * Kind:     Parser specification
 * Author:   Prof. Dr. Juergen Vollmer <vollmer@dhbw-karlsruhe.de>
 * $Id: expr.pars.in,v 1.6 2010/04/26 14:00:29 vollmer Exp $
 */

// Exercises:
//  - Add computation of the "Tree" Attribute to all grammar rules.
//  - Add grammar and tree construction rules to construct an AST for
//    "sin()", "cos()", and "tan()" (see expr.ast)
//    Add a grammar and evaluation rule for the constant    "pi"
//  - Add more test sources to test your grammar

SCANNER expr_scan

PARSER  expr_pars

GLOBAL {
 # include <stdio.h>
 # include "Tree.h"
}

PREC LEFT '<' '>' '=='
     LEFT  '+' '-'
     LEFT  '*' '/'

RULE

root 	= sprache_x
	  {=> {TreeRoot = sprache_x:tree;};}
	.

sprache_x = <
	= 'PROGRAM' i:identifier 'DECLARATIONS' d:decl_l c:codeblock
	   {tree:=mprogram(i:Ident, d:tree, c:tree);}
	.
> .


decl_l	= <
	= /* epsilon */
	  {tree := mno_decls();}
	.
 decls  = <
	= d:decl
	  {tree := mdecls (mno_decls(), d:tree);}
	.
	= l:decls ',' d:decl
	  // left recursive list
	  {tree := mdecls (l:tree, d:tree);}
	.
 > . /* decls */
> . /* decl_l */

decl   = <
	= io:inout t:typ i:identifier
	{tree: mdecl(io, t, i:Ident);}
	.
> .

inout = <
	= 'INPUT' {String erstellen}
	. 
	= 'OUTPUT' {String erstellen}
	.
	= /* epsilon */
	.
> .

typ = <
	= 'STRING' {String erstellen}
	.
	= 'INT' {String erstellen}
	.
	= 'FLOAT' {String erstellen}
	.
> .

codeblock = <
	= 'BEGIN' anw_l 'END.' //Copy-Regel
	.
> .

anw_l	= <
	= /* epsilon */
	  {tree := mno_anws();}
	.
 anws  = <
	= a:anw
	  {tree := manws (mno_anws(), a:tree);}
	.
	= l:anws ',' a:anw
	  // left recursive list
	  {tree := manws (l:tree, a:tree);}
	.
 > . /* anws */
> . /* anw_l */

anw    = < //Copy-Regel?
      = zuwe
      .
      = ifelse
      .
      = whiledo
      .
      = fordo
      .
> .


ifelse = <
	= 'IF' b:bed 'THEN' t:codeblock 'ENDIF.'
	{tree:=mifelse(b:tree, t:tree, mno_anws());}
	.
	= 'IF' b:bed 'THEN' t:codeblock 'ELSE' e:codeblock 'ENDIF.'
	{tree:=mifelse(b:tree, t:tree, e:tree);}
	.
> .

whiledo = <
	= 'WHILE' b:bed 'DO' c:codeblock 'ENDWHILE.'
	{tree:=mwhiledo(b:tree, c:tree);}
	.
> .


fordo   = <
	= 'FOR' b:bed ';' z:zuwe 'DO' c:codeblock 'ENDFOR.'
	{tree:=mfordo(b:tree, z:tree, c:tree);}
	.
> .

bed     = <
	= l:formel c:compop r:formel
	{tree:=mbed(l:tree, r:tree, c:Value);}
	.
> .

compop  = <
	= '>' {String erstellen}
	.
	= '<' {String erstellen}
	.
	= '==' {String erstellen}
	.
> .

zuwe    = <
	= i:identifier '=' f:formel ';'
	{tree:=massignment(i, f:tree);}
	.
> .

formel  = <
	= term //Copy-Regel?
	.
	= l:formel '+' r:term
	{tree:=msumme(l:tree, r:tree);}
	.
	= l:formel '-' r:term
	{tree:=mdifferenz(l:tree, r:tree);}
	.
> .

term    = <
	= negfak //Copy
	.
	= l:term '*' r:negfak
	{tree:=mmultiplikation(l:tree, r:tree);}
	.
	= l:term '/' r:negfak
	{tree:=mdivision(l:tree, r:tree);}
	.
> .

negfak  = <
	= f:faktor //Copy-Regel?
	{tree:=mnegfak(f:tree, '+');}
	.
	= '-' f:faktor
	{tree:=mnegfak(f:tree, '-');}
	.
>.

faktor  = <
	= c:int_const
	{tree := mint_const (c:Position, c:Value);}
	.
	= c:float_const
	{tree := mfloat_const (c:Position, c:Value);}
	.
	= c:string_const
	{tree := mstring_const (c:Position, c);}
	.
	= i:identifier
	{tree := mstring_const (i:Position, i);}
	.
	= '(' formel ')' //Copy-Regel
	.
> .

/* Tokens */
int_const:    [Value: long]   {Value := 0;  } .
float_const:  [Value: double] {Value := 0.0;} .
string_const: [Value: tIdent] {Value := NoIdent;} . //Datentyp?
identifier:   [Ident: tIdent] {Ident := NoIdent; } .

/* non-terminal attributes */
MODULE attributes
PROPERTY SYN
DECLARE
 sprache_x
 decl_l
 decls
 decl
 codeblock
 anw_l
 anws
 anw 
 ifelse
 whiledo 
 fordo
 bed
 compop
 zuwe
 formel
 term
 negfak
 faktor= [tree: tTree].
END attributes